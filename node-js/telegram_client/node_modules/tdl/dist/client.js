"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.TdlError = exports.Client = void 0;

var _path = require("path");

var _eventemitter = _interopRequireDefault(require("eventemitter3"));

var _debug = _interopRequireDefault(require("debug"));

var _util = require("./util");

var prompt = _interopRequireWildcard(require("./prompt"));

var _version = require("./version");

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

const debug = (0, _debug.default)('tdl:client');
const debugEmitter = (0, _debug.default)('tdl:client:emitter');
const debugReceive = (0, _debug.default)('tdl:client:receive');
const debugReq = (0, _debug.default)('tdl:client:request');
const defaultLoginDetails = {
  type: 'user',
  getPhoneNumber: prompt.getPhoneNumber,
  getEmailAddress: prompt.getEmailAddress,
  getEmailCode: prompt.getEmailCode,
  confirmOnAnotherDevice: prompt.confirmOnAnotherDevice,
  getAuthCode: prompt.getAuthCode,
  getPassword: prompt.getPassword,
  getName: prompt.getName
};
const defaultOptions = {
  databaseDirectory: '_td_database',
  filesDirectory: '_td_files',
  databaseEncryptionKey: '',
  verbosityLevel: 2,
  receiveTimeout: 10,
  skipOldUpdates: false,
  useTestDc: false,
  useMutableRename: false,
  useDefaultVerbosityLevel: false,
  bare: false,
  disableAuth: false,
  tdlibParameters: {
    use_message_database: true,
    use_secret_chats: false,
    system_language_code: 'en',
    application_version: '1.0',
    device_model: 'Unknown device',
    system_version: 'Unknown',
    enable_storage_optimizer: true
  }
};

class TdlDeferred {
  constructor() {
    _defineProperty(this, "_innerDefer", void 0);

    _defineProperty(this, "_done", false);
  }

  // Not done or defer not set
  isPending() {
    return !this._done;
  }

  isDone() {
    return this._done;
  }

  isDeferSet() {
    return this._innerDefer != null;
  }

  setDefer(defer) {
    this._innerDefer = defer;
  }

  resolve(result) {
    if (this._done || !this._innerDefer) return;
    this._done = true;

    this._innerDefer.resolve(result);
  }

  reject(error) {
    if (this._done || !this._innerDefer) return;
    this._done = true;

    this._innerDefer.reject(error);
  }

}

class TdlError extends Error {
  constructor(err, msg) {
    super(msg);

    _defineProperty(this, "err", void 0);

    this.err = err;
  }

}

exports.TdlError = TdlError;

const emptyDetails = () => Object.freeze({});

function invariant(cond, msg = 'Invariant violation') {
  if (!cond) throw new Error(msg);
}

const TDLIB_1_8_6 = new _version.Version('1.8.6');
const TDLIB_DEFAULT = new _version.Version('1.8.0');
const TDL_MAGIC = '6c47e6b71ea'; // All public methods in the Client class are meant to be defined as properties.
// Some of the Client functions contain a bit of complicated control flow,
// but it should be fine on a small scale.
// To simplify, Client has three states:
// 1. Created, awaiting initialization (handling of tdlibParameters)
//    - if bare is set to true, go to 3
//    - once authorizationStateWaitTdlibParameters is received and replied with
//      setTdlibParameters, go to 2
//    - what if setTdlibParameters is responded with an error? there is no
//      promise that can be rejected. currently, it is passed to
//      client.login (if it is called) or client.on('error')
//    - On TDLib <= v1.8.5, this also handles authorizationStateWaitEncryptionKey
// 2. Initialized, awaiting client.login (not a real state actually)
//    - arbitrary client.invoke calls are allowed now
//    - if client.login is never called, go to 3
//    - once authorizationStateReady is received, go to 3
// 3. Ready

class Client {
  constructor(tdlibInstance, options = {}) {
    _defineProperty(this, "_tdlib", void 0);

    _defineProperty(this, "_options", void 0);

    _defineProperty(this, "_emitter", new _eventemitter.default());

    _defineProperty(this, "_pending", new Map());

    _defineProperty(this, "_requestId", 0);

    _defineProperty(this, "_client", void 0);

    _defineProperty(this, "_initialized", false);

    _defineProperty(this, "_paused", false);

    _defineProperty(this, "_connectionState", {
      _: 'connectionStateConnecting'
    });

    _defineProperty(this, "_authNeeded", false);

    _defineProperty(this, "_loginDetails", void 0);

    _defineProperty(this, "_loginDefer", new TdlDeferred());

    _defineProperty(this, "_version", TDLIB_DEFAULT);

    _defineProperty(this, "getBackendName", () => {
      return this._tdlib.getName();
    });

    _defineProperty(this, "getVersion", () => {
      if (this._version === TDLIB_DEFAULT) throw new Error('Unknown TDLib version');
      return this._version.toString();
    });

    _defineProperty(this, "login", (getLoginDetails = emptyDetails) => {
      debug('client.login()');

      this._emitter.once('auth-needed', () => {
        this._loginDetails = (0, _util.mergeDeepRight)(defaultLoginDetails, getLoginDetails());
        debug('set _loginDetails to', this._loginDetails);
      });

      return new Promise((resolve, reject) => {
        this._loginDefer.setDefer({
          resolve,
          reject
        });

        this._emitter.emit('_login');
      });
    });

    _defineProperty(this, "loginAsBot", token => {
      return this.login(() => ({
        type: 'bot',
        getToken: retry => retry ? Promise.reject('Invalid bot token') : Promise.resolve(typeof token === 'string' ? token : token())
      }));
    });

    _defineProperty(this, "connect", () => Promise.resolve());

    _defineProperty(this, "connectAndLogin", (fn = emptyDetails) => {
      return this.login(fn);
    });

    _defineProperty(this, "pause", () => {
      if (!this._paused) {
        debug('pause');
        this._paused = true;
      } else {
        debug('pause (no-op)');
      }
    });

    _defineProperty(this, "resume", () => {
      if (this._paused) {
        debug('resume');
        this._paused = false;

        this._emitter.emit('_resume');
      } else {
        debug('resume (no-op)');
      }
    });

    _defineProperty(this, "on", (event, listener) => {
      this._emitter.on(event, listener);

      return this;
    });

    _defineProperty(this, "once", (event, listener) => {
      this._emitter.once(event, listener);

      return this;
    });

    _defineProperty(this, "off", (event, listener, once = false) => {
      this._emitter.removeListener(event, listener, undefined, once);
    });

    _defineProperty(this, "addListener", this.on);

    _defineProperty(this, "removeListener", this.off);

    _defineProperty(this, "emit", (event, value) => {
      debugEmitter('emit', event, value);

      this._emitter.emit(event, value);
    });

    _defineProperty(this, "invoke", async request => {
      if (!this._initialized) await this._waitInit();
      const id = this._requestId;
      this._requestId++;
      if (this._requestId >= Number.MAX_SAFE_INTEGER) this._requestId = 0; // $FlowIgnore[prop-missing]

      request['@extra'] = id;
      const receiveResponse = new Promise((resolve, reject) => {
        const defer = {
          resolve,
          reject
        };

        this._pending.set(id, defer);
      });

      this._send(request);

      return receiveResponse;
    });

    _defineProperty(this, "destroy", () => {
      debug('destroy');
      if (this._client === null) return;

      this._tdlib.destroy(this._client);

      this._client = null;
      this.resume();
      this.emit('destroy');
    });

    _defineProperty(this, "close", () => {
      debug('close');
      return new Promise(resolve => {
        if (this._client === null) return resolve(); // TODO: call this.resume() here?
        // If the client is paused, we can't receive authorizationStateClosed
        // and destroy won't be called

        this._sendTdl({
          _: 'close'
        });

        this._emitter.once('destroy', () => resolve());
      });
    });

    _defineProperty(this, "setLogFatalErrorCallback", fn => {
      this._tdlib.setLogFatalErrorCallback(fn);
    });

    _defineProperty(this, "execute", request => {
      debugReq('execute', request);
      const tdRequest = (0, _util.deepRenameKey)('_', '@type', request); // the client can be null, it's fine

      const tdResponse = this._tdlib.execute(this._client, tdRequest);

      return tdResponse && (0, _util.deepRenameKey)('@type', '_', tdResponse);
    });

    this._options = (0, _util.mergeDeepRight)(defaultOptions, options); // Backward compatibility

    if (this._options.useDefaultVerbosityLevel) this._options.verbosityLevel = 'default';
    if (this._options.disableAuth) this._options.bare = true;

    if (!this._options.bare) {
      var _options$tdlibParamet, _options$tdlibParamet2;

      if (!options.apiId && !((_options$tdlibParamet = options.tdlibParameters) !== null && _options$tdlibParamet !== void 0 && _options$tdlibParamet.api_id)) throw new TypeError('Valid api_id must be provided.');
      if (!options.apiHash && !((_options$tdlibParamet2 = options.tdlibParameters) !== null && _options$tdlibParamet2 !== void 0 && _options$tdlibParamet2.api_hash)) throw new TypeError('Valid api_hash must be provided.');
    }

    this._tdlib = tdlibInstance;

    if (this._options.verbosityLevel !== 'default') {
      debug('Executing setLogVerbosityLevel', this._options.verbosityLevel);

      this._tdlib.execute(null, {
        '@type': 'setLogVerbosityLevel',
        new_verbosity_level: this._options.verbosityLevel
      });
    }

    this._client = this._tdlib.create();
    if (!this._client) throw new Error('Failed to create a TDLib client');
    if (this._options.bare) this._initialized = true; // Note: To allow defining listeners before the first update, we must ensure
    // that emit is not executed in the current tick. process.nextTick or
    // queueMicrotask are redundant here because of await in the _loop function.

    this._loop().catch(e => this._catchError(new TdlError(e)));
  }

  static create(tdlibInstance, options = {}) {
    return new Client(tdlibInstance, options);
  }

  _waitInit() {
    debug('Waiting for initialization');
    if (this._initialized) return Promise.resolve();
    return new Promise(resolve => this._emitter.once('_init', () => resolve()));
  }

  _finishInit() {
    debug('Finished initialization');
    this._initialized = true;

    this._emitter.emit('_init');
  } // Wait until the 'login' function is called
  // After the promise is resolved, the client may or may not be logged in.


  _waitLogin() {
    debug('waitLogin', this._loginDefer);
    return new Promise(resolve => {
      if (this._loginDefer.isDeferSet()) return resolve();

      this._emitter.once('_login', () => resolve());
    });
  }

  _needLoginDetails() {
    if (this._authNeeded) {
      invariant(this._loginDetails != null);
      return this._loginDetails;
    }

    this._authNeeded = true;
    this.emit('auth-needed'); // The auth-needed listener has just set this._loginDetails synchronously

    invariant(this._loginDetails != null);
    return this._loginDetails;
  }

  _needUserLogin() {
    const loginDetails = this._needLoginDetails();

    if (loginDetails.type !== 'user') throw new Error(`Expected user login details, got ${loginDetails.type}`);
    return loginDetails;
  }

  _catchError(err) {
    debug('catchError', err);
    if (this._loginDefer.isPending()) this._loginDefer.reject(err);else this.emit('error', err);
  }

  _waitResume() {
    return new Promise(resolve => {
      if (!this._paused) resolve();

      this._emitter.once('_resume', () => resolve());
    });
  }

  _send(request) {
    debugReq('send', request);
    const tdRequest = (0, _util.deepRenameKey)('_', '@type', request);
    if (this._client === null) throw new Error('A closed client cannot be reused, create a new Client');

    this._tdlib.send(this._client, tdRequest);
  }

  _sendTdl(request) {
    // $FlowIgnore[prop-missing]
    this._send(_objectSpread(_objectSpread({}, request), {}, {
      '@extra': TDL_MAGIC
    }));
  }

  async _receive(timeout = this._options.receiveTimeout) {
    if (this._client === null) return null;
    const tdResponse = await this._tdlib.receive(this._client, timeout); // Note: Immutable rename is used to preserve key order (for better logs)

    return tdResponse && (this._options.useMutableRename ? (0, _util.deepRenameKey_)('@type', '_', tdResponse) : (0, _util.deepRenameKey)('@type', '_', tdResponse));
  }

  async _loop() {
    while (true) {
      if (this._paused) {
        debug('receive loop: waiting for resume');
        await this._waitResume();
        debug('receive loop: resumed');
      }

      if (this._client === null) {
        debug('receive loop: destroyed client'); // TODO: If the fatal error callback is set, it looks like finishing
        // the loop can crash the program with a segmentation fault or
        //  node [...] malloc: *** error for object 0x104a458d0: pointer being freed was not allocated
        //  node [...] malloc: *** set a breakpoint in malloc_error_break to debug
        //  'node index.js' terminated by signal SIGABRT (Abort)
        // This is caused by napi_delete_reference in FunctionReference.

        break;
      }

      const response = await this._receive();

      if (!response) {
        debug('receive loop: response is empty');
        continue;
      }

      try {
        this._handleReceive(response);
      } catch (e) {
        this._catchError(new TdlError(e));
      }
    }
  } // This function can be called with any TDLib object


  _handleReceive(res) {
    this.emit('response', res); // TODO: rename or remove this event

    debugReceive(res);
    const error = res._ === 'error';
    const id = res['@extra'];
    const defer = id != null ? this._pending.get(id) : undefined;

    if (defer != null) {
      // a response to a request made by client.invoke
      delete res['@extra'];
      if (error) defer.reject(res);else defer.resolve(res);

      this._pending.delete(id);

      return;
    }

    if (error) {
      if (id === TDL_MAGIC) {
        // an error to a request sent by tdl itself
        // (i.e., the error should be caused by client.login)
        delete res['@extra'];
        const loginDetails = this._loginDetails;
        if (!loginDetails) return this._catchError(res);

        switch (loginDetails.type) {
          case 'user':
            this._handleUserError(res, loginDetails).catch(e => this._catchError(new TdlError(e)));

            return;

          case 'bot':
            this._handleBotError(res, loginDetails).catch(e => this._catchError(new TdlError(e)));

            return;
        }
      } else {
        // we can't find any request connected to @extra, just emit the error
        // as is. the error can be with or without @extra
        this.emit('error', res);
      }

      return;
    }

    if (id === TDL_MAGIC) {
      // a response to a request sent by tdl itself
      // it's irrelevant, just ignoring it (it's most likely `{ _: 'ok' }`)
      debug('(TDL_MAGIC) Not emitting response', res);
      return;
    } // if the object is not connected to any known request, we treat it as an
    // update. note that in a weird case (maybe if the @extra was manually set)
    // it still can contain the @extra field, this is intended and we want to
    // pass it further to client.on('update')


    this._handleUpdate(res);
  }

  _handleUpdate(update) {
    // updateOption, updateConnectionState, updateAuthorizationState
    // are always emitted, even with skipOldUpdates set to true
    switch (update._) {
      case 'updateOption':
        debug('New option:', update);
        this.emit('update', update);
        if (update.name === 'version' && update.value._ === 'optionValueString') this._version = new _version.Version(update.value.value);
        return;

      case 'updateConnectionState':
        debug('New connection state:', update.state);
        this._connectionState = update.state;
        this.emit('update', update);
        return;

      case 'updateAuthorizationState':
        debug('New authorization state:', update.authorization_state._);
        this.emit('update', update);

        this._handleAuth(update).catch(e => this._catchError(new TdlError(e)));

        return;

      default:
        const shouldSkip = this._options.skipOldUpdates && this._connectionState._ === 'connectionStateUpdating';
        if (shouldSkip) return;
        this.emit('update', update);
    }
  }

  async _handleAuth(update) {
    const authorizationState = update.authorization_state;

    if (authorizationState._ === 'authorizationStateClosed') {
      this._loginDefer.reject(Error('Received authorizationStateClosed'));

      this.destroy();
      return;
    }

    if (this._options.bare) return;

    switch (authorizationState._) {
      case 'authorizationStateWaitTdlibParameters':
        if (this._version.gte(TDLIB_1_8_6)) {
          // $FlowIgnore[prop-missing]
          if (this._options.tdlibParameters._ != null) throw new Error('tdlibParameters must not contain the _ property'); // $FlowIgnore[prop-missing]

          this._sendTdl(_objectSpread({
            _: 'setTdlibParameters',
            database_directory: (0, _path.resolve)(this._options.databaseDirectory),
            files_directory: (0, _path.resolve)(this._options.filesDirectory),
            api_id: this._options.apiId,
            api_hash: this._options.apiHash,
            use_test_dc: this._options.useTestDc,
            database_encryption_key: this._options.databaseEncryptionKey
          }, this._options.tdlibParameters));

          return this._finishInit();
        }

        return this._sendTdl({
          _: 'setTdlibParameters',
          'parameters': _objectSpread(_objectSpread({
            database_directory: (0, _path.resolve)(this._options.databaseDirectory),
            files_directory: (0, _path.resolve)(this._options.filesDirectory),
            api_id: this._options.apiId,
            api_hash: this._options.apiHash,
            use_test_dc: this._options.useTestDc
          }, this._options.tdlibParameters), {}, {
            _: 'tdlibParameters'
          })
        });
      // This update can be received in TDLib <= v1.8.5 only

      case 'authorizationStateWaitEncryptionKey':
        this._sendTdl({
          _: 'checkDatabaseEncryptionKey',
          encryption_key: this._options.databaseEncryptionKey
        });

        return this._finishInit();

      case 'authorizationStateReady':
        // TODO: This will emit even if the login process was manually handled
        if (!this._authNeeded) this.emit('auth-not-needed');
    } // Wait until client.login is called (it may never happen)


    await this._waitLogin();
    debug('waitLogin end', authorizationState._); // Note that authorizationStateWaitPhoneNumber may not be the first update
    // in the login flow in case of a previous incomplete login attempt

    switch (authorizationState._) {
      case 'authorizationStateReady':
        return this._loginDefer.resolve();

      case 'authorizationStateWaitPhoneNumber':
        {
          const loginDetails = this._needLoginDetails();

          switch (loginDetails.type) {
            case 'user':
              return this._sendTdl({
                _: 'setAuthenticationPhoneNumber',
                phone_number: await loginDetails.getPhoneNumber(false)
              });

            case 'bot':
              return this._sendTdl({
                _: 'checkAuthenticationBotToken',
                token: await loginDetails.getToken(false)
              });
          }
        }
      // $FlowIgnore[incompatible-type]: TDLib >= v1.8.6 only

      case 'authorizationStateWaitEmailAddress':
        {
          const loginDetails = this._needUserLogin(); // $FlowIgnore[incompatible-call]


          return this._sendTdl({
            _: 'setAuthenticationEmailAddress',
            email_address: await loginDetails.getEmailAddress()
          });
        }
      // $FlowIgnore[incompatible-type]: TDLib >= v1.8.6 only

      case 'authorizationStateWaitEmailCode':
        {
          const loginDetails = this._needUserLogin(); // $FlowIgnore[incompatible-call]


          return this._sendTdl({
            _: 'checkAuthenticationEmailCode',
            code: {
              // Apple ID and Google ID are not supported
              _: 'emailAddressAuthenticationCode',
              code: await loginDetails.getEmailCode()
            }
          });
        }

      case 'authorizationStateWaitOtherDeviceConfirmation':
        {
          const loginDetails = this._needUserLogin();

          loginDetails.confirmOnAnotherDevice(authorizationState.link);
          return;
        }

      case 'authorizationStateWaitCode':
        {
          const loginDetails = this._needUserLogin();

          const code = await loginDetails.getAuthCode(false);
          return this._sendTdl({
            _: 'checkAuthenticationCode',
            code
          });
        }

      case 'authorizationStateWaitRegistration':
        {
          const loginDetails = this._needUserLogin();

          const {
            firstName,
            lastName = ''
          } = await loginDetails.getName();
          return this._sendTdl({
            _: 'registerUser',
            first_name: firstName,
            last_name: lastName
          });
        }

      case 'authorizationStateWaitPassword':
        {
          const loginDetails = this._needUserLogin();

          const passwordHint = authorizationState.password_hint;
          const password = await loginDetails.getPassword(passwordHint, false);
          return this._sendTdl({
            _: 'checkAuthenticationPassword',
            password
          });
        }
    }
  }

  async _handleUserError(error, loginDetails) {
    switch (error.message) {
      case 'PHONE_CODE_EMPTY':
      case 'PHONE_CODE_INVALID':
        return this._sendTdl({
          _: 'checkAuthenticationCode',
          code: await loginDetails.getAuthCode(true)
        });

      case 'PHONE_NUMBER_INVALID':
        return this._sendTdl({
          _: 'setAuthenticationPhoneNumber',
          phone_number: await loginDetails.getPhoneNumber(true)
        });

      case 'PASSWORD_HASH_INVALID':
        return this._sendTdl({
          _: 'checkAuthenticationPassword',
          password: await loginDetails.getPassword('', true)
        });

      default:
        this._catchError(error);

    }
  }

  async _handleBotError(error, loginDetails) {
    switch (error.message) {
      case 'ACCESS_TOKEN_INVALID':
        return this._sendTdl({
          _: 'checkAuthenticationBotToken',
          token: await loginDetails.getToken(true)
        });

      default:
        this._catchError(error);

    }
  }

}

exports.Client = Client;